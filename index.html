/**
 * Cloud Functions for Firebase - Push Notifications
 * Version: 1.0.1 (Fixed for Firebase Functions v2)
 * 
 * ×ª×¤×§×™×“×Ÿ:
 * 1. ×›×©×œ×§×•×—×” ×™×•×¦×¨×ª ×ª×•×¨ ×—×“×© â†’ ×©×•×œ×—×•×ª ×”×ª×¨××” ×œ×‘×¢×œ×ª ×”×¢×¡×§
 * 2. ×›×©×‘×¢×œ×ª ×”×¢×¡×§ ×××©×¨×ª ×ª×•×¨ â†’ ×©×•×œ×—×•×ª ×”×ª×¨××” ×œ×œ×§×•×—×” (×¢×ª×™×“×™)
 */

const {onDocumentCreated, onDocumentUpdated} = require('firebase-functions/v2/firestore');
const {initializeApp} = require('firebase-admin/app');
const {getFirestore} = require('firebase-admin/firestore');
const {getMessaging} = require('firebase-admin/messaging');

// Initialize Firebase Admin
initializeApp();

/**
 * Cloud Function: × ×©×œ×— ×›×©-×ª×•×¨ ×—×“×© × ×•×¦×¨
 * Trigger: onCreate ×‘×§×•×œ×§×¦×™×” appointments
 */
exports.onNewAppointment = onDocumentCreated('appointments/{appointmentId}', async (event) => {
    try {
        const snapshot = event.data;
        if (!snapshot) {
            console.log('No data associated with the event');
            return;
        }

        const appointment = snapshot.data();
        const appointmentId = event.params.appointmentId;

        console.log('New appointment created:', appointmentId, appointment);

        // ×‘×“×™×§×” ×©×”×ª×•×¨ ×××ª×™×Ÿ ×œ××™×©×•×¨
        if (appointment.status !== 'pending') {
            console.log('Appointment not pending, skipping notification');
            return;
        }

        // ×©×œ×™×¤×ª ×›×œ ×”×˜×•×§× ×™× ×©×œ ×‘×¢×œ×ª ×”×¢×¡×§
        const db = getFirestore();
        const tokensSnapshot = await db
            .collection('fcmTokens')
            .where('isOwner', '==', true)
            .get();

        if (tokensSnapshot.empty) {
            console.log('No owner tokens found');
            return;
        }

        // ×™×¦×™×¨×ª ×¨×©×™××ª ×˜×•×§× ×™×
        const tokens = [];
        tokensSnapshot.forEach(doc => {
            tokens.push(doc.data().token);
        });

        console.log(`Found ${tokens.length} owner token(s)`);

        // ×™×¦×™×¨×ª ×”×•×“×¢×ª ×”×”×ª×¨××”
        const message = {
            notification: {
                title: 'ğŸ”” ×ª×•×¨ ×—×“×© ×××ª×™×Ÿ!',
                body: `${appointment.name} ××‘×§×©×ª ${appointment.treatment} ×‘-${formatDate(appointment.date)} ×‘×©×¢×” ${appointment.time}`
            },
            data: {
                appointmentId: appointmentId,
                type: 'new_appointment',
                date: appointment.date,
                time: appointment.time,
                customerName: appointment.name
            }
        };

        // ×©×œ×™×—×ª ×”×”×ª×¨××” ×œ×›×œ ×”×˜×•×§× ×™×
        const messaging = getMessaging();
        const sendPromises = tokens.map(token => {
            return messaging.send({
                ...message,
                token: token
            }).catch(async (error) => {
                console.error('Error sending to token:', token, error);
                // ×× ×”×˜×•×§×Ÿ ×œ× ×ª×§×£, × ××—×§ ××•×ª×•
                if (error.code === 'messaging/invalid-registration-token' ||
                    error.code === 'messaging/registration-token-not-registered') {
                    const snapshot = await db
                        .collection('fcmTokens')
                        .where('token', '==', token)
                        .get();
                    
                    const deletePromises = [];
                    snapshot.forEach(doc => {
                        deletePromises.push(doc.ref.delete());
                    });
                    await Promise.all(deletePromises);
                }
                return null;
            });
        });

        await Promise.all(sendPromises);
        console.log('Notifications sent successfully');
        
    } catch (error) {
        console.error('Error in onNewAppointment:', error);
    }
});

/**
 * Cloud Function: × ×©×œ×— ×›×©-×ª×•×¨ ×××•×©×¨ ××• × ×“×—×”
 * Trigger: onUpdate ×‘×§×•×œ×§×¦×™×” appointments
 */
exports.onAppointmentUpdate = onDocumentUpdated('appointments/{appointmentId}', async (event) => {
    try {
        const beforeData = event.data.before.data();
        const afterData = event.data.after.data();
        const appointmentId = event.params.appointmentId;

        console.log('Appointment updated:', appointmentId);

        // ×‘×“×™×§×” ×× ×”×¡×˜×˜×•×¡ ×”×©×ª× ×” ×-pending ×œ-approved
        if (beforeData.status === 'pending' && afterData.status === 'approved') {
            console.log('Appointment approved, sending notification to customer');

            // ×›××Ÿ ××¤×©×¨ ×œ×”×•×¡×™×£ ×œ×•×’×™×§×” ×œ×©×œ×™×—×ª ×”×ª×¨××” ×œ×œ×§×•×—×”
            // ×›×¨×’×¢ ×–×” ×¤×©×•×˜ ×œ×•×’, ×›×™ ×œ×§×•×—×•×ª ×œ× ×¨×•×©××•×ª ×˜×•×§× ×™×
            // ×‘×¢×ª×™×“ ××¤×©×¨ ×œ×”×•×¡×™×£ SMS ××• email ×›××Ÿ

            console.log(`Appointment approved: ${afterData.name}, ${afterData.date} ${afterData.time}`);
            
            // TODO: ×”×•×¡×£ ×›××Ÿ ×©×œ×™×—×ª SMS ×“×¨×š Twilio ××• Email
        }

    } catch (error) {
        console.error('Error in onAppointmentUpdate:', error);
    }
});

/**
 * ×¤×•× ×§×¦×™×™×ª ×¢×–×¨: ×¤×•×¨××˜ ×ª××¨×™×š ×œ×¢×‘×¨×™×ª
 */
function formatDate(dateString) {
    const date = new Date(dateString);
    return date.toLocaleDateString('he-IL', { 
        weekday: 'long', 
        day: 'numeric', 
        month: 'long' 
    });
}
